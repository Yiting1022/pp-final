#!/usr/bin/env python3
"""calibrate_from_data.py

Read historical CSVs for:
- single underlying (e.g., AAPL) from data/single
- 8-stock basket from data/multi

and estimate simple GBM parameters:
- S0: last close price
- sigma_annual: sqrt(252) * std(daily log returns)
- for basket: equicorrelation rho = average off-diagonal

Outputs a small shell snippet (params.sh) that exports
these parameters, so src/gpu/run_all.sh can source it
and feed real-market parameters into the GPU pricers.
"""

import argparse
import os
from pathlib import Path

import numpy as np
import pandas as pd


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Calibrate GBM parameters from CSV price data")
    p.add_argument("--single-csv", type=str, default="data/single/AAPL.csv",
                   help="CSV path for single-asset underlying (default: data/single/AAPL.csv)")
    p.add_argument("--multi-dir", type=str, default="data/multi",
                   help="Directory of 8 CSVs for basket assets (default: data/multi)")
    p.add_argument("--out", type=str, default="params.sh",
                   help="Output shell script with exported parameters (default: params.sh)")
    p.add_argument("--trading-days", type=int, default=252,
                   help="Trading days per year for annualization (default: 252)")
    return p.parse_args()


def load_prices(csv_path: str) -> pd.Series:
    df = pd.read_csv(csv_path)
    # Try common column names for close price
    for col in ["Adj Close", "Close", "close", "adj_close"]:
        if col in df.columns:
            return df[col].astype(float)
    raise ValueError(f"No close/adj-close column found in {csv_path}")


def estimate_sigma(prices: pd.Series, trading_days: int) -> float:
    log_ret = np.log(prices.astype(float)).diff().dropna()
    if len(log_ret) < 2:
        raise ValueError("Not enough observations to estimate volatility")
    daily_std = float(log_ret.std(ddof=1))
    return daily_std * np.sqrt(trading_days)


def calibrate_single(single_csv: str, trading_days: int) -> tuple[float, float]:
    prices = load_prices(single_csv)
    S0 = float(prices.iloc[-1])
    sigma = estimate_sigma(prices, trading_days)
    return S0, sigma


def calibrate_multi(multi_dir: str, trading_days: int) -> tuple[float, float, float]:
    path = Path(multi_dir)
    csvs = sorted(path.glob("*.csv"))
    if len(csvs) == 0:
        raise ValueError(f"No CSV files found in {multi_dir}")

    # Load all price series and align by index length (use min length)
    series_list = []
    for f in csvs:
        s = load_prices(str(f))
        series_list.append(s.reset_index(drop=True))

    min_len = min(len(s) for s in series_list)
    if min_len < 3:
        raise ValueError("Not enough data points in multi-asset series")

    prices_mat = np.stack([s.iloc[-min_len:].to_numpy(dtype=float) for s in series_list], axis=1)

    # Daily log returns matrix: shape (T-1, N)
    log_ret = np.diff(np.log(prices_mat), axis=0)

    # Annualized vol per asset
    daily_std = log_ret.std(axis=0, ddof=1)
    sigma_assets = daily_std * np.sqrt(trading_days)
    sigma_mean = float(sigma_assets.mean())

    # Correlation matrix & equicorrelation rho (average off-diagonal)
    corr = np.corrcoef(log_ret.T)
    n = corr.shape[0]
    if n > 1:
        off_diag = corr[np.triu_indices(n, k=1)]
        rho = float(off_diag.mean())
    else:
        rho = 0.0

    # Basket S0: equal-weighted last prices
    last_prices = prices_mat[-1, :]
    S0_basket = float(last_prices.mean())

    return S0_basket, sigma_mean, rho


def main() -> None:
    args = parse_args()

    S0_single, sigma_single = calibrate_single(args.single_csv, args.trading_days)
    S0_multi, sigma_multi, rho_multi = calibrate_multi(args.multi_dir, args.trading_days)

    out_lines = [
        "# Auto-generated by tools/calibrate_from_data.py",
        f"export S0_SINGLE={S0_single}",
        f"export SIGMA_SINGLE={sigma_single}",
        f"export S0_MULTI={S0_multi}",
        f"export SIGMA_MULTI={sigma_multi}",
        f"export RHO_MULTI={rho_multi}",
    ]

    with open(args.out, "w", encoding="utf-8") as f:
        f.write("\n".join(out_lines) + "\n")

    print("[calibrate] Wrote parameters to", args.out)
    for line in out_lines[1:]:
        print("  ", line)


if __name__ == "__main__":
    main()
